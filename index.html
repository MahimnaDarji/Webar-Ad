<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebAR Ad</title>

  <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

  <style>
    html, body { margin: 0; height: 100%; background: #000; }
    #camPreview{ position: fixed; inset: 0; width: 100vw; height: 100vh; object-fit: cover; z-index: 0; background:#000; }
    a-scene{ position: fixed; inset: 0; z-index: 1; }
    .hint{
      position: fixed; left: 50%; top: 18%; transform: translateX(-50%);
      z-index: 10; padding: 10px 16px; border-radius: 12px;
      color:#fff; font: 700 20px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: rgba(0,0,0,.5); text-shadow: 0 2px 3px rgba(0,0,0,.6);
      pointer-events: none;
    }
    .hint.hidden{ display:none; }
  </style>
</head>
<body>
  <video id="camPreview" autoplay playsinline muted></video>
  <div id="hint" class="hint">Point your camera at your printed ad</div>

  <a-scene
    mindar-image="imageTargetSrc: ./assets/ad.mind;
                  filterMinCF: 0.0005; filterBeta: 0.01; warmupTolerance: 5; missTolerance: 7"
    color-space="sRGB"
    renderer="alpha: true; colorManagement: true; physicallyCorrectLights: true; antialias: true"
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: false">

    <a-assets>
      <!-- ad.png is used to determine target aspect ratio -->
      <img id="adImage" src="./assets/ad.png" crossorigin="anonymous">
      <video id="adVideo" src="./assets/ad.mp4" preload="auto" playsinline webkit-playsinline muted loop crossorigin="anonymous"></video>
    </a-assets>

    <a-camera position="0 0 0" look-controls="enabled:false"></a-camera>

    <!-- Anchor on the detected image. Children lie exactly on that plane. -->
    <a-entity id="anchor" mindar-image-target="targetIndex: 0">
      <a-plane id="videoPlane"
               material="shader: flat; src: #adVideo; side: double; transparent: false"
               position="0 0 0.001" rotation="0 0 0"
               width="1" height="1">
      </a-plane>
    </a-entity>
  </a-scene>

  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const scene   = document.querySelector('a-scene');
      const preview = document.getElementById('camPreview');
      const hint    = document.getElementById('hint');
      const anchor  = document.getElementById('anchor');
      const vPlane  = document.getElementById('videoPlane');
      const adImg   = document.getElementById('adImage');
      const video   = document.getElementById('adVideo');

      // Attach MindAR camera to visible preview
      function attachPreview(){
        try{
          const ms = scene.systems['mindar-image-system'];
          const iv = ms && ms.video;
          if (iv && iv.srcObject) { 
            preview.srcObject = iv.srcObject; 
            return true; 
          }
        }catch(e){}
        return false;
      }
      
      const tryAttach = () => { 
        if (!attachPreview()) setTimeout(tryAttach, 150); 
      };
      
      scene.addEventListener('loaded', tryAttach);

      // Get the material map for UV adjustments
      function getMap(){
        const mesh = vPlane.getObject3D('mesh');
        return (mesh && mesh.material && mesh.material.map) ? mesh.material.map : null;
      }

      // Apply object-fit: cover behavior to video texture
      function applyCoverUV(targetAspect, videoAspect){
        const map = getMap();
        if (!map) { 
          setTimeout(() => applyCoverUV(targetAspect, videoAspect), 50); 
          return; 
        }
        
        // Reset UV mapping to defaults
        map.center.set(0.5, 0.5);
        map.repeat.set(1, 1);
        map.offset.set(0, 0);
        
        // Apply cover scaling
        if (Math.abs(videoAspect - targetAspect) > 0.01) { // Only if aspects differ significantly
          if (videoAspect > targetAspect) {
            // Video is wider than target - crop sides
            const scale = targetAspect / videoAspect;
            map.repeat.set(scale, 1);
            map.offset.set((1 - scale) / 2, 0);
          } else {
            // Video is taller than target - crop top/bottom
            const scale = videoAspect / targetAspect;
            map.repeat.set(1, scale);
            map.offset.set(0, (1 - scale) / 2);
          }
        }
        
        map.needsUpdate = true;
        
        // Disable frustum culling and ensure proper rendering
        const mesh = vPlane.getObject3D('mesh');
        if (mesh) {
          mesh.frustumCulled = false;
          if (mesh.material) {
            mesh.material.needsUpdate = true;
          }
        }
      }

      // Get target aspect ratio from multiple sources
      function getTargetAspect(){
        let targetAspect = 16/9; // Default fallback
        
        try {
          // First, try to get from MindAR metadata
          const ms = scene.systems['mindar-image-system'];
          if (ms && ms.controller && ms.controller.imageTargets && ms.controller.imageTargets[0]) {
            const target = ms.controller.imageTargets[0];
            if (target.width && target.height) {
              targetAspect = target.width / target.height;
              console.log('Using MindAR target aspect:', targetAspect);
              return targetAspect;
            }
          }
          
          // Fallback to image dimensions
          if (adImg.naturalWidth > 0 && adImg.naturalHeight > 0) {
            targetAspect = adImg.naturalWidth / adImg.naturalHeight;
            console.log('Using image aspect:', targetAspect);
            return targetAspect;
          }
        } catch(e) {
          console.warn('Error getting target aspect:', e);
        }
        
        console.log('Using default aspect:', targetAspect);
        return targetAspect;
      }

      // Size the plane to match the target perfectly
      function sizePlaneToTarget(){
        const targetAspect = getTargetAspect();
        
        // In MindAR, the target width is normalized to 1
        const planeWidth = 1.0;
        const planeHeight = planeWidth / targetAspect;
        
        // Position at exact center of target (0,0,0 in target space)
        vPlane.setAttribute('position', '0 0 0.001'); // Slightly above to avoid z-fighting
        vPlane.setAttribute('width', planeWidth);
        vPlane.setAttribute('height', planeHeight);
        
        // Apply video texture mapping
        const videoAspect = (video.videoWidth || video.clientWidth || 16) / (video.videoHeight || video.clientHeight || 9);
        console.log('Target aspect:', targetAspect, 'Video aspect:', videoAspect);
        
        applyCoverUV(targetAspect, videoAspect);
      }

      // Wait for all resources to be ready
      function waitForReady(){
        const imageReady = adImg.complete && adImg.naturalWidth > 0;
        const videoReady = video.readyState >= 2; // HAVE_CURRENT_DATA
        
        if (imageReady && videoReady) {
          sizePlaneToTarget();
          console.log('Resources ready, plane sized');
        } else {
          console.log('Waiting for resources...', {imageReady, videoReady});
          setTimeout(waitForReady, 100);
        }
      }

      // Event listeners for resource loading
      adImg.addEventListener('load', () => {
        console.log('Image loaded:', adImg.naturalWidth, 'x', adImg.naturalHeight);
        waitForReady();
      });
      
      video.addEventListener('loadeddata', () => {
        console.log('Video loaded:', video.videoWidth, 'x', video.videoHeight);
        waitForReady();
      });

      // Start checking if resources are ready
      waitForReady();

      // Handle target tracking events
      anchor.addEventListener('targetFound', async () => {
        console.log('Target found');
        hint.classList.add('hidden');
        
        // Ensure plane is properly sized when target is found
        sizePlaneToTarget();
        
        // Start video playback
        try { 
          await video.play(); 
          console.log('Video playing');
        } catch(e) {
          console.log('Auto-play blocked, waiting for user interaction');
          const resume = () => { 
            video.play().catch(() => {}); 
            window.removeEventListener('touchend', resume); 
            window.removeEventListener('click', resume); 
          };
          window.addEventListener('touchend', resume, { once: true });
          window.addEventListener('click', resume, { once: true });
        }
      });
      
      anchor.addEventListener('targetLost', () => {
        console.log('Target lost');
        hint.classList.remove('hidden');
        video.pause();
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        setTimeout(sizePlaneToTarget, 100);
      });
    });
  </script>
</body>
</html>
