<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebAR Ad — Perfect Fit</title>

  <!-- A-Frame -->
  <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
  <!-- MindAR (image tracking) for A-Frame -->
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

  <style>
    html, body { margin: 0; height: 100%; background: #000; }

    /* Hide MindAR's default scanning/loading UI */
    .mindar-ui, .mindar-ui-scanning, .mindar-ui-loading {
      display: none !important;
    }

    /* Live camera preview behind the AR canvas */
    #camPreview{
      position: fixed; inset: 0;
      width: 100vw; height: 100vh;
      object-fit: cover; z-index: 0; background: #000;
    }

    /* Scene (transparent canvas so preview shows through) */
    a-scene{ position: fixed; inset: 0; z-index: 1; }

    .ui, .footer{
      position: fixed; left: 0; right: 0; z-index: 10; color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; text-align: center;
      text-shadow: 0 1px 2px rgba(0,0,0,.6);
    }
    .ui{ top: 0; padding: 10px 14px; background: linear-gradient(rgba(0,0,0,.55), rgba(0,0,0,0)); }
    .footer{ bottom: 0; padding: 10px 14px; background: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,.55)); font-size: 13px; }

    /* === Custom Scanner Frame (resizable) === */
    #scanFrame{
      --scan-size: 80vmin;     /* visual guide; doesn't affect tracking */
      position: fixed; inset: 0; margin: auto; 
      z-index: 9999;
      width: var(--scan-size);
      height: calc(var(--scan-size) * 0.56); /* 16:9 window for guidance only */
      border-radius: 14px; pointer-events: none;
      box-shadow: 0 0 40px rgba(0,0,0,.35) inset;
    }
    #scanFrame::before{
      content: ""; position: absolute; inset: 0; border-radius: 14px;
      border: 5px solid rgba(255,255,255,0.9);
    }
    #scanFrame.hidden{ display: none; }
  </style>
</head>
<body>
  <!-- Visible camera preview -->
  <video id="camPreview" autoplay playsinline muted></video>

  <!-- Bigger custom scanner frame (hides on targetFound) -->
  <div id="scanFrame" aria-hidden="true"></div>

  <div class="ui">Point your camera at your printed ad (or open <code>/assets/ad.png</code> on another screen)</div>
  <div class="footer">Serve from <strong>http://localhost</strong> or HTTPS. Allow camera access.</div>

  <a-scene
    mindar-image="imageTargetSrc: ./assets/ad.mind"
    color-space="sRGB"
    renderer="alpha: true; colorManagement: true; physicallyCorrectLights: true; antialias: true"
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: false"
  >
    <a-assets>
      <!-- Your print image (used only for alignment preview) -->
      <img id="adImage" src="./assets/ad.png" crossorigin="anonymous">
      <!-- Your video -->
      <video id="adVideo" src="./assets/ad.mp4" preload="auto" webkit-playsinline playsinline muted loop crossorigin="anonymous"></video>
    </a-assets>

    <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

    <a-entity id="targetRoot" mindar-image-target="targetIndex: 0">
      <!-- We will set width/height precisely in JS after reading real aspect ratios -->
      <a-plane id="adPlane" src="#adImage" position="0 0 0" rotation="0 0 0" width="1" height="0.56"></a-plane>

      <a-plane id="videoPlane"
               material="shader: flat; src: #adVideo"
               position="0 0 0.001"
               rotation="0 0 0"
               width="1"
               height="0.56">
      </a-plane>

      <a-text value="Playing…" align="center" position="0 -0.7 0.001" scale="0.6 0.6 0.6" color="#ffffff"></a-text>
    </a-entity>
  </a-scene>

  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const scene = document.querySelector('a-scene');
      const preview = document.getElementById('camPreview');
      const scanFrame = document.getElementById('scanFrame');
      const root = document.getElementById('targetRoot');

      const adImg = document.getElementById('adImage');
      const adPlane = document.getElementById('adPlane');

      const video = document.getElementById('adVideo');
      const videoPlane = document.getElementById('videoPlane');

      const FIT_MODE = 'cover';  
      const BASE_WIDTH = 1.0;   
      const OFFSET_X = 0.000;   
      const OFFSET_Y = 0.000;    
      const SCALE_X  = 1.000;    
      const SCALE_Y  = 1.000;

      // ====== Attach MindAR camera stream to visible preview ======
      const attachPreview = () => {
        try {
          const mindarSystem = scene.systems['mindar-image-system'];
          const internalVideo = mindarSystem && mindarSystem.video;
          if (internalVideo && internalVideo.srcObject) {
            preview.srcObject = internalVideo.srcObject;
            return true;
          }
        } catch (e) {}
        return false;
      };
      const tryAttach = () => { if (!attachPreview()) setTimeout(tryAttach, 150); };
      scene.addEventListener('loaded', tryAttach);

      // ====== Compute precise sizes after media is ready ======
      function sizePlanes() {
        // 1) Real aspect ratios
        const adAspect = adImg.naturalWidth / adImg.naturalHeight;          // W/H
        const videoAspect = (video.videoWidth || 16) / (video.videoHeight || 9);

        // 2) Size the AD plane to match the tracked image proportions exactly
        // MindAR normalizes target width; we use BASE_WIDTH = 1
        const adWidth = BASE_WIDTH;
        const adHeight = adWidth / adAspect;
        adPlane.setAttribute('width', adWidth);
        adPlane.setAttribute('height', adHeight);

        // 3) Size the VIDEO plane using fit mode relative to ad plane
        let vidWidth, vidHeight;
        if (FIT_MODE === 'contain') {
          // Fit entirely within ad plane (no crop)
          // Match whichever side is the limiting dimension
          const heightIfWidthMatches = adWidth / videoAspect;
          if (heightIfWidthMatches <= adHeight) {
            vidWidth = adWidth;
            vidHeight = heightIfWidthMatches;
          } else {
            vidHeight = adHeight;
            vidWidth = adHeight * videoAspect;
          }
        } else { // 'cover' default — fill the ad fully (edge-to-edge), allow minimal crop
          const heightIfWidthMatches = adWidth / videoAspect;
          if (heightIfWidthMatches >= adHeight) {
            // Full width doesn't give enough height — scale up by height
            vidHeight = adHeight;
            vidWidth = adHeight * videoAspect;
          } else {
            // Full height doesn't give enough width — scale up by width
            vidWidth = adWidth;
            vidHeight = adWidth / videoAspect;
          }
        }

        // 4) Micro-adjustments
        vidWidth  *= SCALE_X;
        vidHeight *= SCALE_Y;

        videoPlane.setAttribute('width', vidWidth);
        videoPlane.setAttribute('height', vidHeight);
        videoPlane.setAttribute('position', `${OFFSET_X} ${OFFSET_Y} 0.001`);

        // Optional: keep label below correctly
        const labelY = -(adHeight / 2) - 0.14; // place label just below the ad
        const label = root.querySelector('a-text');
        if (label) label.setAttribute('position', `0 ${labelY} 0.001`);
      }

      // Wait for both resources
      function whenReady() {
        if (adImg.complete && adImg.naturalWidth > 0 && video.readyState >= 1) {
          sizePlanes();
        } else {
          setTimeout(whenReady, 60);
        }
      }
      // Kick off once metadata is available
      adImg.addEventListener('load', whenReady);
      video.addEventListener('loadedmetadata', whenReady);
      // In case they are cached/instant
      whenReady();

      // ====== Scanner visibility + video play/pause ======
      root.addEventListener('targetFound', async () => {
        scanFrame.classList.add('hidden');
        try { await video.play(); }
        catch (e) {
          const resume = () => { video.play().catch(()=>{}); window.removeEventListener('touchend', resume); window.removeEventListener('click', resume); };
          window.addEventListener('touchend', resume, { once: true });
          window.addEventListener('click', resume, { once: true });
        }
      });

      root.addEventListener('targetLost', () => {
        scanFrame.classList.remove('hidden');
        video.pause();
      });
    });
  </script>
</body>
</html>
