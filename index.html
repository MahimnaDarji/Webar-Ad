<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebAR Ad â€” Oversized Video Overlay (Stabilized)</title>

  <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

  <style>
    html, body { margin: 0; height: 100%; background: #000; }
    #camPreview{ position: fixed; inset: 0; width: 100vw; height: 100vh; object-fit: cover; z-index: 0; background:#000; }
    a-scene{ position: fixed; inset: 0; z-index: 1; }
    .hint{
      position: fixed; left: 50%; top: 18%; transform: translateX(-50%);
      z-index: 10; padding: 10px 16px; border-radius: 12px;
      color:#fff; font: 700 20px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: rgba(0,0,0,.5); text-shadow: 0 2px 3px rgba(0,0,0,.6);
      pointer-events: none;
    }
    .hint.hidden{ display:none; }
  </style>
</head>
<body>
  <video id="camPreview" autoplay playsinline muted></video>
  <div id="hint" class="hint">Point your camera at your printed ad</div>

  <a-scene
    mindar-image="imageTargetSrc: ./assets/ad.mind;
                  filterMinCF: 0.0005; filterBeta: 0.01; warmupTolerance: 5; missTolerance: 7"
    color-space="sRGB"
    renderer="alpha: true; colorManagement: true; physicallyCorrectLights: true; antialias: true"
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: false">

    <a-assets>
      <img id="adImage" src="./assets/ad.png" crossorigin="anonymous">
      <video id="adVideo" src="./assets/ad.mp4" preload="auto" playsinline webkit-playsinline muted loop crossorigin="anonymous"></video>
    </a-assets>

    <a-camera position="0 0 0" look-controls="enabled:false"></a-camera>

    <!-- Anchor on the detected image. Children lie exactly on that plane. -->
    <a-entity id="anchor" mindar-image-target="targetIndex: 0"></a-entity>

    <!-- STABILIZED entity (world-following the anchor with smoothing) -->
    <a-entity id="stabilized"
              pose-smoother="anchor: #anchor; lerpPos: 0.18; slerpRot: 0.18; lerpScale: 0.18">
      <a-plane id="videoPlane"
               material="shader: flat; src: #adVideo; side: double; transparent: false"
               position="0 0 0"
               rotation="0 0 0"
               width="1.5" height="1.5">
      </a-plane>
    </a-entity>
  </a-scene>

  <!-- ===== Pose Smoothing Component (video stability) ===== -->
  <script>
    AFRAME.registerComponent('pose-smoother', {
      schema: {
        anchor:   { type: 'selector' }, // required: the MindAR anchor entity to follow
        lerpPos:  { default: 0.2 },     // 0..1, higher = faster, lower = smoother
        slerpRot: { default: 0.2 },
        lerpScale:{ default: 0.2 }
      },
      init: function () {
        this.tmpPos   = new THREE.Vector3();
        this.tmpQuat  = new THREE.Quaternion();
        this.tmpScale = new THREE.Vector3(1,1,1);

        this.smPos   = new THREE.Vector3();
        this.smQuat  = new THREE.Quaternion();
        this.smScale = new THREE.Vector3(1,1,1);

        this.initialized = false;

        // Optional: small ring buffer for additional temporal smoothing on position/scale
        this.bufSize = 5;
        this.posBuf = Array(this.bufSize).fill(new THREE.Vector3());
        this.sclBuf = Array(this.bufSize).fill(new THREE.Vector3(1,1,1));
        this.bufIdx = 0;

        // Visibility handling (show/hide when target is found/lost)
        if (this.data.anchor) {
          this.data.anchor.addEventListener('targetFound', () => { this.el.object3D.visible = true; });
          this.data.anchor.addEventListener('targetLost',  () => { this.el.object3D.visible = false; });
        }
        this.el.object3D.visible = false; // hidden until target found
      },
      averageBuffer: function (buf) {
        const acc = new THREE.Vector3();
        for (let i=0;i<buf.length;i++) acc.add(buf[i]);
        acc.multiplyScalar(1 / buf.length);
        return acc;
      },
      tick: function () {
        const anchor = this.data.anchor;
        if (!anchor) return;

        const aobj = anchor.object3D;
        if (!aobj) return;

        // Decompose anchor's world transform
        aobj.updateMatrixWorld(true);
        aobj.matrixWorld.decompose(this.tmpPos, this.tmpQuat, this.tmpScale);

        // Feed buffers
        this.posBuf[this.bufIdx] = this.tmpPos.clone();
        this.sclBuf[this.bufIdx] = this.tmpScale.clone();
        this.bufIdx = (this.bufIdx + 1) % this.bufSize;

        // Compute buffered (averaged) target transforms
        const avgPos = this.averageBuffer(this.posBuf);
        const avgScl = this.averageBuffer(this.sclBuf);

        if (!this.initialized) {
          this.smPos.copy(avgPos);
          this.smQuat.copy(this.tmpQuat);
          this.smScale.copy(avgScl);
          this.initialized = true;
        } else {
          // Exponential smoothing towards the averaged target
          this.smPos.lerp(avgPos, this.data.lerpPos);
          THREE.Quaternion.slerp(this.smQuat, this.tmpQuat, this.smQuat, this.data.slerpRot);
          this.smScale.lerp(avgScl, this.data.lerpScale);
        }

        // Apply smoothed transform to this entity in WORLD SPACE
        const o = this.el.object3D;
        o.position.copy(this.smPos);
        o.quaternion.copy(this.smQuat);
        o.scale.copy(this.smScale);
        o.matrixWorldNeedsUpdate = true;

        // Extra: ensure child mesh is never culled (prevents flicker at edges)
        const mesh = this.el.getObject3D('mesh');
        if (mesh) mesh.traverse(m => { m.frustumCulled = false; });
      }
    });
  </script>
  <!-- ===== /Pose Smoothing Component ===== -->

  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const scene   = document.querySelector('a-scene');
      const preview = document.getElementById('camPreview');
      const hint    = document.getElementById('hint');
      const anchor  = document.getElementById('anchor');
      const vPlane  = document.getElementById('videoPlane');
      const adImg   = document.getElementById('adImage');
      const video   = document.getElementById('adVideo');

      // Scale factor for oversizing the video
      const SCALE_FACTOR = 1.3;

      // Attach MindAR camera to visible preview
      function attachPreview(){
        try{
          const ms = scene.systems['mindar-image-system'];
          const iv = ms && ms.video;
          if (iv && iv.srcObject) {
            preview.srcObject = iv.srcObject;
            return true;
          }
        }catch(e){}
        return false;
      }

      const tryAttach = () => {
        if (!attachPreview()) setTimeout(tryAttach, 150);
      };
      scene.addEventListener('loaded', tryAttach);

      // Calculate target aspect ratio from image
      function getTargetAspectRatio() {
        if (adImg.naturalWidth > 0 && adImg.naturalHeight > 0) {
          return adImg.naturalWidth / adImg.naturalHeight;
        }
        return 16 / 9; // fallback
      }

      // Size the video plane to be larger than target
      function setupVideoPlane() {
        // Get target aspect ratio
        const targetAspect = getTargetAspectRatio();

        // In MindAR coordinate system, target width is normalized to 1
        const targetWidth = 1.0;
        const targetHeight = targetWidth / targetAspect;

        // Make video plane larger by scale factor
        const planeWidth = targetWidth * SCALE_FACTOR;
        const planeHeight = targetHeight * SCALE_FACTOR;

        // Apply dimensions to the plane
        vPlane.setAttribute('width', planeWidth);
        vPlane.setAttribute('height', planeHeight);
        vPlane.setAttribute('position', '0 0 0');

        // Ensure texture mapping is reset & no culling
        setTimeout(() => {
          const mesh = vPlane.getObject3D('mesh');
          if (mesh) {
            mesh.traverse(m => { m.frustumCulled = false; });
            if (mesh.material && mesh.material.map) {
              const map = mesh.material.map;
              map.center.set(0.5, 0.5);
              map.repeat.set(1, 1);
              map.offset.set(0, 0);
              map.needsUpdate = true;
            }
          }
        }, 100);
      }

      // Wait for image to load to get proper dimensions
      function waitForImageLoad() {
        if (adImg.complete && adImg.naturalWidth > 0) {
          setupVideoPlane();
        } else {
          setTimeout(waitForImageLoad, 100);
        }
      }

      adImg.addEventListener('load', setupVideoPlane);
      video.addEventListener('loadedmetadata', () => {
        // can log video dimensions if needed
      });

      waitForImageLoad();

      // Handle target tracking
      anchor.addEventListener('targetFound', async () => {
        hint.classList.add('hidden');

        // Re-apply sizing to ensure it's correct
        setTimeout(setupVideoPlane, 200);

        // Start video playback
        try {
          await video.play();
        } catch {
          const resume = () => {
            video.play().catch(()=>{});
            window.removeEventListener('touchend', resume);
            window.removeEventListener('click', resume);
          };
          window.addEventListener('touchend', resume, { once: true });
          window.addEventListener('click', resume, { once: true });
        }
      });

      anchor.addEventListener('targetLost', () => {
        hint.classList.remove('hidden');
        video.pause();
      });
    });
  </script>
</body>
</html>
